from enum import Enum
from queue import Queue
from typing import List, Optional, Iterator

from mapfmclient import MarkedLocation

from src.util.agent import Agent
from src.util.coord import Coord


class HeuristicType(Enum):
    Heuristic = 1
    Exhaustive = 2
    Hungarian = 3


class Grid:

    def __init__(self, grid: List[List[int]], width: int, height: int, starts: List[MarkedLocation],
                 goals: List[MarkedLocation], heuristic_type: HeuristicType):
        """
        Create a grid
        :param grid: The actual grid: 1 for wall 0 for open
        :param width: The width
        :param height: The height
        :param starts: The starting locations
        :param goals: The goal locations
        :param heuristic_type: The heuristic type
        """
        self.grid = grid
        self.w = width
        self.h = height
        self.starts = starts
        self.goals = goals
        self.heuristics = None
        self.compute_heuristics(heuristic_type)

    def compute_heuristics(self, heuristic_type):
        """
        Compute the heuristics based on the type
        :param heuristic_type: The heuristic type
        """
        self.heuristics = [self.compute_goal_heuristic(goal.x, goal.y) for goal in self.goals]

    def compute_goal_heuristic(self, x, y) -> List[List[Optional[int]]]:
        """
        Compute the heuristics as the distance to the given coordinates
        :param x: The x location
        :param y: The y location
        :return: A distance matrix to this location
        """
        queue = Queue()
        queue.put((Coord(x, y), 0))
        return self.compute_heuristic(queue)

    def compute_color_heuristic(self, color) -> List[List[Optional[int]]]:
        """
        Compute a distance heuristic for the given color
        :param color: The color
        :return: A distance matrix to the nearest goal of the given color
        """
        queue = Queue()
        for goal in self.goals:
            if goal.color == color:
                queue.put((Coord(goal.x, goal.y), 0))
        return self.compute_heuristic(queue)

    def compute_heuristic(self, queue) -> List[List[Optional[int]]]:
        """
        Computes the heuristic by running a breath-first search with the starting locations in the queue
        :param queue: The initial queue
        :return: A distance matrix generated by a BFS
        """
        visited = set()
        heuristic = [[None for _ in range(self.w)] for _ in range(self.h)]
        while not queue.empty():
            coord, dist = queue.get()
            if coord in visited:
                continue
            visited.add(coord)

            # Already has a better distance
            if heuristic[coord.y][coord.x] is not None:
                continue
            heuristic[coord.y][coord.x] = dist

            for neighbor in self.get_neighbors(coord):
                if neighbor not in visited:
                    queue.put((neighbor, dist + 1))
        return heuristic

    def get_neighbors(self, coords: Coord) -> List[Coord]:
        """
        Gets the valid neighbours of the coordinates.
        :param coords: The coordinates
        :return: The neighbours
        """
        res = list()
        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            new_coord = coords.move(dx, dy)
            if self.is_walkable(new_coord):
                res.append(new_coord)
        return res

    def get_heuristic(self, coord, index: int) -> Optional[int]:
        """
        Return the heuristic value for the given idnex at the given location.
        Index depends on the heuristic type.
        :param coord: The location
        :param index: Either the color or the goal id, depending on heuristic type
        :return: The heuristic
        """
        return self.heuristics[index][coord.y][coord.x]

    def is_walkable(self, coord) -> bool:
        """
        If a location is on the grid and if there is no wall.
        :param coord: The location
        :return: If the location is free
        """
        return 0 <= coord.x < self.w and 0 <= coord.y < self.h and not self.is_wall(coord)

    def is_wall(self, coord) -> bool:
        """
        Checks if there is a wall at a location.
        :param coord: The location
        :return: True if there is a wall
        """
        return self.grid[coord.y][coord.x] == 1

    def is_final(self, agents: Iterator[Agent]) -> bool:
        """
        Checks if all agents are on a valid goal.
        :param agents: The agents
        :return: True if all of them are on a valid goal
        """
        return all(self.on_goal(agent) for agent in agents)

    def on_goal(self, agent: Agent) -> bool:
        """
        Checks if the agent is on a valid goal
        :param agent: The agent
        :return: True if it is on a valid goal
        """
        for goal in self.goals:
            if agent.color == goal.color and agent.coords.x == goal.x and agent.coords.y == goal.y:
                return True
        return False
